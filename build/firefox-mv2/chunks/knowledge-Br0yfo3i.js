var u=Object.defineProperty;var w=(a,r,e)=>r in a?u(a,r,{enumerable:!0,configurable:!0,writable:!0,value:e}):a[r]=e;var n=(a,r,e)=>(w(a,typeof r!="symbol"?r+"":r,e),e);import{d as h,a as g}from"./Sidebar-ChItARQ9.js";import{h as d}from"./get-screenshot-dbUggNeo.js";const y=()=>"pa_knowledge_xxxx-xxxx-xxx-xxxx".replace(/[x]/g,()=>Math.floor(Math.random()*16).toString(16));class o{constructor(){n(this,"db");n(this,"getAll",async()=>new Promise((r,e)=>{this.db.get(null,t=>{if(chrome.runtime.lastError)e(chrome.runtime.lastError);else{const s=Object.keys(t).map(c=>t[c]);r(s)}})}));n(this,"getById",async r=>new Promise((e,t)=>{this.db.get(r,s=>{chrome.runtime.lastError?t(chrome.runtime.lastError):e(s[r])})}));n(this,"create",async r=>new Promise((e,t)=>{this.db.set({[r.id]:r},()=>{chrome.runtime.lastError?t(chrome.runtime.lastError):(d.knowledge.afterCreate(r),e())})}));n(this,"update",async r=>new Promise((e,t)=>{this.db.set({[r.id]:r},()=>{chrome.runtime.lastError?t(chrome.runtime.lastError):(d.knowledge.afterUpdate(r),e())})}));n(this,"delete",async r=>new Promise((e,t)=>{this.db.remove(r,()=>{chrome.runtime.lastError?t(chrome.runtime.lastError):(d.knowledge.afterDelete(r),e())})}));n(this,"deleteSource",async(r,e)=>new Promise((t,s)=>{this.db.get(r,c=>{if(chrome.runtime.lastError)s(chrome.runtime.lastError);else{const i=c[r];i.source=i.source.filter(m=>m.source_id!==e),this.db.set({[r]:i},()=>{chrome.runtime.lastError?s(chrome.runtime.lastError):(d.knowledge.afterUpdate(i),t())})}})}));this.db=chrome.storage.local}}const f=async({source:a,title:r,embedding_model:e})=>{const t=new o,s={id:y(),title:r,db_type:"knowledge",source:a,status:"pending",knownledge:{},embedding_model:e,createdAt:Date.now()};return await t.create(s),s},p=async a=>new o().getById(a),l=async(a,r)=>{var s;const e=new o,t=await e.getById(a);r==="finished"&&(t.source=(s=t==null?void 0:t.source)==null?void 0:s.map(c=>({...c,content:void 0}))),await e.update({...t,status:r})},x=async(a,r)=>{await l(a,"processing");const e=new o,t=await e.getById(a);await e.update({...t,source:[...t.source,...r]})},b=async a=>{const r=await new o().getAll();return a?r.filter(e=>(e==null?void 0:e.db_type)==="knowledge").filter(e=>(e==null?void 0:e.status)===a).map(e=>(e.source.forEach(t=>{delete t.content}),e)).sort((e,t)=>t.createdAt-e.createdAt):r.filter(e=>(e==null?void 0:e.db_type)==="knowledge").map(e=>(e==null||e.source.forEach(t=>{delete t.content}),e)).sort((e,t)=>t.createdAt-e.createdAt)},E=async a=>{await new o().delete(a),await g(`vector:${a}`)},k=async(a,r)=>{await new o().deleteSource(a,r),await h(`vector:${a}`,r)},A=async()=>await new o().getAll(),_=async a=>{const r=new o;for(const e of a)await r.create(e)};export{p as a,x as b,f as c,k as d,A as e,E as f,b as g,_ as i,l as u};
